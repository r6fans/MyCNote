/*1.叙述线性结构的特点；写一个算法，删除单链表的头节点

答：线性结构的特点
1. 线性结构元素之间存在唯一的前驱和后继，即每个元素只有一个前驱和后继
2. 元素之间是一对一的关系，不存在一对多或者多对多的关系
3. 元素在结构中有固定的位置，每个元素都有一个唯一的位置
4. 元素的插入和删除只能在特定位置进行*/

//删除单链表的头节点
Node *Delete_head(Node *pHead){
    if(pHead==NULL){
        return NULL; //最后有一个节点被删除时，返回NULL
    }
    Node *pTemp = pHead->next; //临时存储头节点的下一个节点，便于制作新的头节点
    free(pHead);
    if(pTemp==NULL){   //最后一个节点被删除时pTemp为空，则返回NULL
        return NULL;
    }
    //pHead指向的内存已经被释放
    pHead=pTemp; //通过pTemp让头指针指向第二个节点
    return pHead;
}

/*2
a. 栈是什么？有什么特点
b. 描述该算法的过程(可用自然语言)
c. 画图展示该算法的运行过程

a. 栈是用来存储逻辑关系为“一对一”数据关系的线性结构，同顺序表和链表一样。
特点：1. 栈只能用从表的一端存取数据，另一端是封闭的；2. 在栈中需要遵循先进后出的原则

b. 算法步骤
1. 将s入栈
2. 将栈顶元素出栈
3. 探索栈顶元素周围按照右上左下的顺序判断是否为可着色节点，可着色节点必须满足 该点是像素点不是边界点且该点并未被染色
4. 将合法的可染色节点入栈
5. 重复步骤2-4直到栈为空*/

/*3. 综合快速排序，回答一下问题
叙述冒泡排序的过程
设计实例，叙述快速排序的过程

答： 冒泡排序过程
比较两个相邻的元素，将值大的元素交换到右边
过程：依次比较相邻的两个数，将比较小的元素放在前面，较大的数放后面
1. 第一次比较：首先比较第一和第二个数，将小数放前面，大数放后面
2. 比较第二和第三个数，将小数放前面大数放后面
3. 如此继续，直到比较最后两个数，将小数放前面大数放后面，重复步骤，直到排序完成
4. 在上面一趟比较完成后，最后一个数一定是数组中最大的一个数，所以比较第二趟的时候，最后一个数不参加比较
5. 在第二趟排序完成后倒数第二个数一定是数组中倒数第二大的数，所以第三趟的比较中最后两数不比较
6. 以此类推，每趟排序比较次数减一

使用序列{49，38，65，97，76，13，27，49}来叙述快速排序过程，pivot为基准
起始状态 pivot=49
{49，38，65，97，76，13，27，49}
  i                          j

*/

/*4.结合计算机算法设计与分析
a. 什么是动态规划？动态规划与分治法的区别是什么？
b. 举例说明，动态规划求解最优化问题的过

a. 动态规划法是将复杂问题分解成更小的子问题，并将子问题的解缓存起来，以便保证每个子问题只需要求解一次，避免重复计算。动态规划法通过把问题分解为若干个重叠子问题，递归的求解子问题，并把子问题的解保存在一个查找表中，从而最终得出主问题的解。
分治法也是将问题分解成规模更小的子问题，并将子问题的解合并来求最终的主问题的解。分治法与动态规划法的区别在于子问题是否重复，动态规划法用于解决有重叠子问题的问题，分支用于解决子问题不重复的情况

b. 用0-1背包问题举例

在N件物品中取出若干件放在容量为W的背包中，每件物品的体积为W1,W2,....Wn(Wi为整数)，与之相对应的价值为P1,P2....Pn(Pi为整数)，求解背包能够容纳的最大价值。要解决最大的问题是n个物品的规模缩小为考虑前n-1个物品的(1,2,...c)
的背包容量等c个子问题。依次向前类推，当我们考虑只有1个物品时，最优解显然容易求解，再自底向上来求解大问题。当我们求解出子问题的最优解时，采用*/

/*5.*/
